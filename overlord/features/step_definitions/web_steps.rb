# # Taken from the cucumber-rails project.
# # IMPORTANT: This file is generated by cucumber-sinatra - edit at your own peril.
# # It is recommended to regenerate this file in the future when you upgrade to a
# # newer version of cucumber-sinatra. Consider adding your own code to a new file
# # instead of editing this one. Cucumber will automatically load all features/**/*.rb
# # files.
#
# require 'uri'
# require 'cgi'
#
# require File.expand_path(File.join(File.dirname(__FILE__), "..", "support", "paths"))
#
# module WithinHelpers
#   def with_scope(locator)
#     locator ? within(locator) { yield } : yield
#   end
# end
#
# World(WithinHelpers)
#
# # (I) am on $page_name
# Given /^(?:|I )am on (.+)$/ do |page_name|
#   visit path_to(page_name)
# end
#
# # (I) go to $page_name
# When /^(?:|I )go to (.+)$/ do |page_name|
#   visit path_to(page_name)
# end
#
# # (I) press $button (within $selector)
# When /^(?:|I )press "([^\"]*)"(?: within "([^\"]*)")?$/ do |button, selector|
#   with_scope(selector) do
#     click_button(button)
#   end
# end
#
# # (I) follow $link (within $selector)
# When /^(?:|I )follow "([^\"]*)"(?: within "([^\"]*)")?$/ do |link, selector|
#   with_scope(selector) do
#     click_link(link)
#   end
# end
#
# # (I) fill in $field with $value (within $selector)
# When /^(?:|I )fill in "([^\"]*)" with "([^\"]*)"(?: within "([^\"]*)")?$/ do |field, value, selector|
#   with_scope(selector) do
#     fill_in(field, :with => value)
#   end
# end
#
# # (I) fill in $value for $field (within $selector)
# When /^(?:|I )fill in "([^\"]*)" for "([^\"]*)"(?: within "([^\"]*)")?$/ do |value, field, selector|
#   with_scope(selector) do
#     fill_in(field, :with => value)
#   end
# end
#
# # Use this to fill in an entire form with data from a table. Example:
# #
# #   When I fill in the following:
# #     | Account Number | 5002       |
# #     | Expiry date    | 2009-11-01 |
# #     | Note           | Nice guy   |
# #     | Wants Email?   |            |
# #
# # TODO: Add support for checkbox, select og option
# # based on naming conventions.
# #
# When /^(?:|I )fill in the following(?: within "([^\"]*)")?:$/ do |selector, fields|
#   with_scope(selector) do
#     fields.rows_hash.each do |name, value|
#       When %{I fill in "#{name}" with "#{value}"}
#     end
#   end
# end
#
# # (I) select $value from $field (within $selector)
# When /^(?:|I )select "([^\"]*)" from "([^\"]*)"(?: within "([^\"]*)")?$/ do |value, field, selector|
#   with_scope(selector) do
#     select(value, :from => field)
#   end
# end
#
# # (I) check $field (within $selector)
# When /^(?:|I )check "([^\"]*)"(?: within "([^\"]*)")?$/ do |field, selector|
#   with_scope(selector) do
#     check(field)
#   end
# end
#
# # (I) uncheck $field (within $selector)
# When /^(?:|I )uncheck "([^\"]*)"(?: within "([^\"]*)")?$/ do |field, selector|
#   with_scope(selector) do
#     uncheck(field)
#   end
# end
#
# # (I) choose $field (within $selector)
# When /^(?:|I )choose "([^\"]*)"(?: within "([^\"]*)")?$/ do |field, selector|
#   with_scope(selector) do
#     choose(field)
#   end
# end
#
# # (I) attach the file $path to $field (within $selector)
# When /^(?:|I )attach the file "([^\"]*)" to "([^\"]*)"(?: within "([^\"]*)")?$/ do |path, field, selector|
#   with_scope(selector) do
#     attach_file(field, path)
#   end
# end
#
# # (I) should see $expected_json
# Then /^(?:|I )should see JSON:$/ do |expected_json|
#   require 'json'
#   expected = JSON.pretty_generate(JSON.parse(expected_json))
#   actual   = JSON.pretty_generate(JSON.parse(response.body))
#   expected.should == actual
# end
#
# # (I) should see $text (within $selector)
# Then /^(?:|I )should see "([^\"]*)"(?: within "([^\"]*)")?$/ do |text, selector|
#   with_scope(selector) do
#     if page.respond_to? :should
#       page.should have_content(text)
#     else
#       assert page.has_content?(text)
#     end
#   end
# end
#
# # (I) should see $regexp (within $selector)
# Then /^(?:|I )should see \/([^\/]*)\/(?: within "([^\"]*)")?$/ do |regexp, selector|
#   regexp = Regexp.new(regexp)
#   with_scope(selector) do
#     if page.respond_to? :should
#       page.should have_xpath('//*', :text => regexp)
#     else
#       assert page.has_xpath?('//*', :text => regexp)
#     end
#   end
# end
#
# # (I) should not see $text (within $selector)
# Then /^(?:|I )should not see "([^\"]*)"(?: within "([^\"]*)")?$/ do |text, selector|
#   with_scope(selector) do
#     if page.respond_to? :should
#       page.should have_no_content(text)
#     else
#       assert page.has_no_content?(text)
#     end
#   end
# end
#
# # (I) should not see $regexp (within $selector)
# Then /^(?:|I )should not see \/([^\/]*)\/(?: within "([^\"]*)")?$/ do |regexp, selector|
#   regexp = Regexp.new(regexp)
#   with_scope(selector) do
#     if page.respond_to? :should
#       page.should have_no_xpath('//*', :text => regexp)
#     else
#       assert page.has_no_xpath?('//*', :text => regexp)
#     end
#   end
# end
#
# # the $field (within $selector) should contain $value
# Then /^the "([^\"]*)" field(?: within "([^\"]*)")? should contain "([^\"]*)"$/ do |field, selector, value|
#   with_scope(selector) do
#     field = find_field(field)
#     field_value = (field.tag_name == 'textarea') ? field.text : field.value
#     if field_value.respond_to? :should
#       field_value.should =~ /#{value}/
#     else
#       assert_match(/#{value}/, field_value)
#     end
#   end
# end
#
# # the $field field (within $selector) should not contain $value
# Then /^the "([^\"]*)" field(?: within "([^\"]*)")? should not contain "([^\"]*)"$/ do |field, selector, value|
#   with_scope(selector) do
#     field = find_field(field)
#     field_value = (field.tag_name == 'textarea') ? field.text : field.value
#     if field_value.respond_to? :should_not
#       field_value.should_not =~ /#{value}/
#     else
#       assert_no_match(/#{value}/, field_value)
#     end
#   end
# end
#
# # the $label checkbox (within $selector) should be checked
# Then /^the "([^\"]*)" checkbox(?: within "([^\"]*)")? should be checked$/ do |label, selector|
#   with_scope(selector) do
#     field_checked = find_field(label)['checked']
#     if field_checked.respond_to? :should
#       field_checked.should == 'checked'
#     else
#       assert_equal 'checked', field_checked
#     end
#   end
# end
#
# # the label $checkbox (within $selector) should not be checked.
# Then /^the "([^\"]*)" checkbox(?: within "([^\"]*)")? should not be checked$/ do |label, selector|
#   with_scope(selector) do
#     field_checked = find_field(label)['checked']
#     if field_checked.respond_to? :should_not
#       field_checked.should_not == 'checked'
#     else
#       assert_not_equal 'checked', field_checked
#     end
#   end
# end
#
# # (I) should be on $page_name
# Then /^(?:|I )should be on (.+)$/ do |page_name|
#   current_path = URI.parse(current_url).path
#   if current_path.respond_to? :should
#     current_path.should == path_to(page_name)
#   else
#     assert_equal path_to(page_name), current_path
#   end
# end
#
# # (I) should have the following query string
# Then /^(?:|I )should have the following query string:$/ do |expected_pairs|
#   query = URI.parse(current_url).query
#   actual_params = query ? CGI.parse(query) : {}
#   expected_params = {}
#   expected_pairs.rows_hash.each_pair{|k,v| expected_params[k] = v.split(',')}
#
#   if actual_params.respond_to? :should
#     actual_params.should == expected_params
#   else
#     assert_equal expected_params, actual_params
#   end
# end
#
# # show me the page
# Then /^show me the page$/ do
#   save_and_open_page
# end
